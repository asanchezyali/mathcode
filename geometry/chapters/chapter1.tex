\chapter{Preliminares}
\label{chap:preliminares}

La Geometría es, posiblemente, la rama más antigua de las matemáticas. Sus aplicaciones fueron estudiadas hace miles de
años por egipcios, babilonios y chinos, mientras que su teoría fue desarrollada por los griegos. Lo que distingue el
estudio moderno de la geometría del antiguo es el \emph{método axiomático}, piedra angular sobre la cual descansa toda
la matemática pura. En este capítulo exploraremos las bases de los sistemas formales y cómo estos conceptos teóricos se
traducen en algoritmos ejecutables.

\section{Sistemas formales}

El núcleo metodológico de las matemáticas reside en el \textbf{método axiomático}. Este enfoque se fundamenta en la
postulación de un conjunto inicial de enunciados denominados \textbf{axiomas}, los cuales deben ser mutuamente
consistentes e idealmente independientes entre sí. Este cuerpo de proposiciones conforma lo que denominamos un
\textbf{sistema axiomático} o \textbf{sistema formal}, donde el punto de partida de toda cadena deductiva son los
axiomas: proposiciones que se asumen como verdaderas sin necesidad de demostración previa.

¿Por qué necesitamos axiomas? La respuesta está en un problema lógico fundamental: no es posible justificar una afirmación partiendo de la nada. Si una proposición se sostiene en otra, entonces surge la pregunta de cómo se justifica esta última. A su vez, necesitaría apoyarse en una tercera, y así sucesivamente. Si seguimos este razonamiento, nos encontramos con una regresión infinita de justificaciones, como una cadena interminable de dominós. Para evitar este problema, es necesario aceptar ciertas proposiciones como verdaderas sin necesidad de demostración. Estas proposiciones son los axiomas.

El método axiomático puede resumirse en los siguientes principios:
\begin{enumerate}
    \item Todo sistema axiomático debe contener un conjunto de \textbf{términos primitivos}, deliberadamente elegidos como
          indefinidos y sujetos a la interpretación del lector.
    \item Todos los demás términos técnicos del sistema se definen a partir de los términos primitivos. Estos son las
          \textbf{definiciones} del sistema.
    \item El sistema contiene un conjunto de enunciados sobre términos primitivos y definiciones que se eligen sin demostrar.
          Estos son los \textbf{axiomas} del sistema.
    \item Todos los demás enunciados del sistema deben ser consecuencias lógicas de los axiomas. Estos enunciados derivados se
          denominan \textbf{teoremas}.
\end{enumerate}

Desde una perspectiva computacional, un sistema formal es un mecanismo de manipulación de signos puramente sintáctico.
Está constituido por un alfabeto de símbolos que se \textbf{concatenan} para formar secuencias (o cadenas), las cuales
son manipuladas siguiendo reglas estrictas para producir nuevas secuencias. Esta capacidad de manipulación simbólica
permite que el sistema funcione como una representación estructurada, permitiéndonos explorar relaciones lógicas y
deducciones mediante razonamientos formales.

En disciplinas como la informática, la teoría de la información y la estadística, estos sistemas actúan como gramáticas
formales diseñadas para la modelización. Al proceso de construir estos sistemas se le llama \textbf{formalización}: un
acto de abstracción mediante el cual estructuramos conceptos y relaciones en un lenguaje formal riguroso.

Para implementar computacionalmente un sistema formal, se requiere definir cuatro elementos:
\begin{enumerate}
    \item Un \textbf{alfabeto} de símbolos primitivos.
    \item Un conjunto de reglas gramaticales para definir las \textbf{fórmulas bien formadas} (cadenas válidas).
    \item Un conjunto de fórmulas bien formadas iniciales llamadas \textbf{axiomas}.
    \item Un conjunto finito de \textbf{reglas de inferencia} para derivar nuevos teoremas.
\end{enumerate}

\subsection{El Acertijo MU: Un enfoque computacional}

En esta sección estudiaremos el acertijo \texttt{MU}, el cual representa un sistema formal minimalista. Este problema
fue planteado por Douglas Hofstadter en 1979 en su obra seminal \emph{Gödel, Escher, Bach: Un Eterno y Grácil
    Bucle}\footnote{Una lectura recomendada para entender la recursividad y la inteligencia artificial.}.

El objetivo es producir la cadena \texttt{MU} (de ahí su nombre) dentro de un sistema formal conocido como el
\textbf{sistema MIU}. El nombre deriva de su alfabeto, compuesto exclusivamente por tres símbolos: \texttt{M},
\texttt{I}, \texttt{U}. Esto significa que las cadenas del sistema estarán formadas únicamente por combinaciones de
estas tres letras.

\subsubsection{Definición del sistema MIU}

El sistema parte de una cadena inicial o axioma: la cadena \texttt{MI}. A partir de ella, se pueden generar nuevas
cadenas aplicando reglas de transformación. Si definimos $x$ e $y$ como variables que representan cualquier cadena de
símbolos del sistema, las reglas son:

\begin{itemize}
    \item \textbf{Regla 1 (Adición de U).} Si una cadena termina en \texttt{I}, se puede agregar una \texttt{U} al final.
          \[ xI \implies xIU \]
          \emph{Ejemplo:} Si tenemos \texttt{MII}, podemos derivar \texttt{MIIU}.

    \item \textbf{Regla 2 (Duplicación).} Si una cadena comienza con \texttt{M}, se puede duplicar todo lo que sigue.
          \[ Mx \implies Mxx \]
          \emph{Ejemplo:} De \texttt{MIU} se deriva \texttt{MIUIU}.

    \item \textbf{Regla 3 (Reducción de III).} Si aparece la secuencia \texttt{III}, se puede sustituirse por \texttt{U}.
          \[ xIIIy \implies xUy \]
          \emph{Ejemplo:} De \texttt{UMIIIMU} se deriva \texttt{UMUMU}. Nótese que las tres \texttt{I} deben ser consecutivas.

    \item \textbf{Regla 4 (Eliminación de UU).} Si aparece la secuencia \texttt{UU}, está permitida su eliminación.
          \[ xUUy \implies xy \]
          \emph{Ejemplo:} De \texttt{MUUUIII} se deriva \texttt{MUIII}.
\end{itemize}

\subsubsection{Exploración del espacio de búsqueda}

Generar teoremas en un sistema formal es equivalente a realizar una \emph{búsqueda en un espacio de estados}, donde
cada estado es una cadena válida y las transiciones son las reglas de inferencia. Esta perspectiva computacional
justifica el uso de algoritmos de búsqueda para explorar el sistema.

Para intentar resolver el acertijo, procedemos a generar cadenas manualmente partiendo del axioma \texttt{MI}:
\begin{enumerate}
    \item Aplicando la Regla 2 a \texttt{MI}, obtenemos \texttt{MII}.
    \item Aplicando la Regla 1 a \texttt{MI}, obtenemos \texttt{MIU}.
\end{enumerate}

Este proceso genera una estructura de árbol (\autoref{fig:treeMIU}). Sin embargo, a diferencia de los árboles binarios
simples, aquí el factor de ramificación es variable. Por ejemplo, la cadena \texttt{MIIIIIIIU} permite múltiples
aplicaciones de la Regla 3 en diferentes posiciones, generando diversos hijos.

\begin{figure}[h!]
    \centering
    \Tree[.MI [.MIU [.MIUIU MIUIUIUIU ]] [.MII [.MIIU MIIUIIU ] [.MIIII [.MIIIIU ][.MIIIIIIII ][.MUI ]]]]
    \caption{Árbol de cadenas bien formadas (teoremas) en el sistema formal $MIU$.}
    \label{fig:treeMIU}
\end{figure}

\subsubsection{Implementación algorítmica}

Dado que el árbol de derivación crece exponencialmente, la exploración manual se vuelve inviable rápidamente. Aquí es
donde la programación se convierte en una herramienta indispensable para las matemáticas.

El algoritmo para generar todas las derivaciones posibles de una cadena se puede expresar de manera abstracta mediante
el siguiente pseudocódigo:

\begin{algorithm}[H]
    \caption{Derivaciones en el sistema MIU}
    \KwEntrada{Una cadena $s$ del sistema MIU}
    \KwSalida{Conjunto de todas las cadenas derivables en un paso}
    $D \leftarrow \emptyset$\;
    \tcp{Regla 1: $xI \Rightarrow xIU$}
    \Si{$s$ termina en $I$}{
        $D \leftarrow D \cup \{s + U\}$\;
    }
    \tcp{Regla 2: $Mx \Rightarrow Mxx$}
    \Si{$s$ comienza con $M$}{
        Sea $x$ la subcadena después de $M$\;
        $D \leftarrow D \cup \{M + x + x\}$\;
    }
    \tcp{Regla 3: $xIIIy \Rightarrow xUy$}
    \ParaCada{posición $i$ donde aparece $III$ en $s$}{
    $D \leftarrow D \cup \{s[0{:}i] + U + s[i{+}3{:}]\}$\;
    }
    \tcp{Regla 4: $xUUy \Rightarrow xy$}
    \ParaCada{posición $i$ donde aparece $UU$ en $s$}{
    $D \leftarrow D \cup \{s[0{:}i] + s[i{+}2{:}]\}$\;
    }
    \Retornar{$D$}\;
\end{algorithm}

A continuación, traducimos este pseudocódigo a Python:

\codefile[listing options={language=Python}, title={Código 1.1: Implementación de las reglas del sistema MIU en Python}]{code/miu_rules.py}

Este código nos permite automatizar la expansión del árbol y explorar niveles más profundos del espacio de búsqueda.

\subsubsection{La imposibilidad de MU}

Después de explorar el árbol de derivaciones, surge una pregunta natural: ¿es posible alcanzar \texttt{MU}? La
respuesta es \textbf{no}, y la demostración es un ejemplo elegante de razonamiento matemático.

La clave está en observar un \textbf{invariante}: una propiedad que se preserva bajo todas las reglas del sistema.
Contemos las letras $I$ en cada cadena y clasifiquémoslas según el \textbf{residuo} al dividir entre 3. Por ejemplo:
una letra $I$ deja residuo 1; dos letras dejan residuo 2; tres letras dejan residuo 0; cuatro letras dejan residuo 1
(porque $4 = 3 + 1$), y así sucesivamente.

Analicemos cómo cada regla afecta este residuo:
\begin{itemize}
    \item \textbf{Estado inicial:} La cadena \texttt{MI} tiene una sola letra $I$, por lo que su residuo es 1.
    \item \textbf{Regla 1} (añadir \texttt{U}): No altera el número de letras $I$, así que el residuo permanece igual.
    \item \textbf{Regla 2} (duplicar): Duplica las $I$. Si el residuo era 1, pasa a ser 2. Si era 2, pasa a ser 1
          (porque $2 \times 2 = 4$, y $4$ deja residuo 1). Nótese que el residuo 0 pasaría a 0.
    \item \textbf{Regla 3} (\texttt{III} $\to$ \texttt{U}): Elimina exactamente tres letras $I$, lo cual no cambia el
          residuo (restar 3 no afecta el residuo módulo 3).
    \item \textbf{Regla 4} (eliminar \texttt{UU}): No involucra letras $I$, por lo que el residuo no cambia.
\end{itemize}

Partiendo de residuo 1, solo podemos alcanzar residuos 1 o 2, pero \textbf{nunca 0}. La cadena \texttt{MU} no tiene
letras $I$ (residuo 0), lo cual es imposible de alcanzar desde \texttt{MI}.

Este resultado ilustra un principio fundamental: a veces, la exploración computacional no basta. Se requiere un
argumento matemático que trascienda la búsqueda exhaustiva. El acertijo MU nos enseña que trabajar \emph{dentro} de un
sistema formal tiene límites, y que para entender verdaderamente sus propiedades debemos \emph{salir} de él y razonar
desde una perspectiva externa.

\begin{exercise}
    Implementa en Python una función \texttt{es\_derivable(cadena)} que determine si una cadena dada es alcanzable desde
    \texttt{MI} en el sistema MIU. La función debe:
    \begin{enumerate}
        \item Verificar que la cadena comience con \texttt{M} y solo contenga los símbolos \texttt{M}, \texttt{I}, \texttt{U}.
        \item Contar el número de letras \texttt{I} en la cadena.
        \item Calcular el residuo de ese número al dividir entre 3.
        \item Retornar \texttt{True} si el residuo es 1 o 2, y \texttt{False} si es 0.
    \end{enumerate}
    Prueba tu función con las cadenas \texttt{MU}, \texttt{MIU}, \texttt{MIUIU} y \texttt{MUII}.
\end{exercise}

\begin{exercise}
    Considera un sistema axiomático minimalista con dos tipos de objetos: \textbf{Fe}'s y \textbf{Fo}'s. Los axiomas
    del sistema son:
    \begin{enumerate}
        \item Existen exactamente tres Fe's.
        \item Para cada par de Fe's distintos, existe exactamente un Fo al cual ambos pertenecen.
        \item No todos los Fe's pertenecen al mismo Fo.
        \item Dos Fo's distintos tienen al menos un Fe en común.
    \end{enumerate}
    A partir de estos axiomas, demuestra las siguientes proposiciones:
    \begin{enumerate}
        \item[(a)] Cada Fo tiene exactamente dos Fe's que le pertenecen.
        \item[(b)] Un Fo está completamente caracterizado por los Fe's que contiene. Es decir, si dos Fo's son distintos,
              entonces no contienen los mismos Fe's.
        \item[(c)] Dos Fo's distintos tienen exactamente un Fe en común.
        \item[(d)] Existen exactamente tres Fo's distintos.
    \end{enumerate}
\end{exercise}